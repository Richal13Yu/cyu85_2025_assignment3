<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = async function () {

    var scene = new BABYLON.Scene(engine);
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 1, -5), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.attachControl(canvas, true);

    const arAvailable = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync('immersive-ar');

    const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("FullscreenUI");
    const rectangle = new BABYLON.GUI.Rectangle("rect");
    rectangle.background = "black";
    rectangle.color = "blue";
    rectangle.width = "80%";
    rectangle.height = "50%";
    advancedTexture.addControl(rectangle);
    const nonXRPanel = new BABYLON.GUI.StackPanel();
    rectangle.addControl(nonXRPanel);

    const text1 = new BABYLON.GUI.TextBlock("text1");
    text1.fontFamily = "Helvetica";
    text1.textWrapping = true;
    text1.color = "white";
    text1.fontSize = "14px";
    text1.height = "400px"
    text1.paddingLeft = "10px";
    text1.paddingRight = "10px";
 
    if (!arAvailable) {
        text1.text = "AR is not available in your system. Please make sure you use a supported device such as a Meta Quest 3 or a modern Android device and a supported browser like Chrome.\n \n Make sure you have Google AR services installed and that you enabled the WebXR incubation flag under chrome://flags";
        nonXRPanel.addControl(text1);
        return scene;
    } else {
        text1.text = "WebXR Demo: Hit test and depth sensing.\n \n Please enter AR with the button on the lower right corner to start. Once in AR, look at the floor for a few seconds (and move a little): the hit-testing ring will appear. Then click anywhere on the screen to place a model in your space.";
        nonXRPanel.addControl(text1);
    }

    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    var dirLight = new BABYLON.DirectionalLight('dir', new BABYLON.Vector3(0, -1, -0.5), scene);
    dirLight.position = new BABYLON.Vector3(0, 5, -5);

    var shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight);
    shadowGenerator.useBlurExponentialShadowMap = true;
    shadowGenerator.blurKernel = 32;

    const model = await BABYLON.SceneLoader.ImportMeshAsync("", "./", "blue_crab.glb", scene);
    const crab = model.meshes[0];
    crab.rotationQuaternion = new BABYLON.Quaternion();
    crab.isVisible = false;
    crab.scaling = new BABYLON.Vector3(0.02, 0.02, 0.02);
    shadowGenerator.addShadowCaster(crab, true);

    const hl = new BABYLON.HighlightLayer("hl1", scene);

    const xr = await scene.createDefaultXRExperienceAsync({
        uiOptions: { sessionMode: 'immersive-ar' },
        optionalFeatures: true
    });

    xr.baseExperience.sessionManager.onXRSessionInit.add(() => { rectangle.isVisible = false; });
    xr.baseExperience.sessionManager.onXRSessionEnded.add(() => { rectangle.isVisible = true; });

    xr.baseExperience.featuresManager.enableFeature(
        BABYLON.WebXRFeatureName.DEPTH_SENSING,
        "latest",
        { dataFormatPreference: ["ushort", "float"], usagePreference: ["cpu", "gpu"] }
    );

    const fm = xr.baseExperience.featuresManager;
    fm.enableFeature(BABYLON.WebXRBackgroundRemover.Name);

    const marker = BABYLON.MeshBuilder.CreateTorus('marker', { diameter: 0.15, thickness: 0.05 });
    marker.isVisible = false;
    marker.rotationQuaternion = new BABYLON.Quaternion();

    let hitTestSource = null;
    let currentResult = null;
    let CrabList = [];
    let selectedModel = null;

    xr.input.onControllerAddedObservable.add(async (controller) => {
        controller.onMotionControllerInitObservable.add((motionController) => {
            if (motionController.handedness !== 'right') return;

            const session = xr.baseExperience.sessionManager.session;
            const referenceSpace = xr.baseExperience.sessionManager.referenceSpace;

            session.requestHitTestSource({ space: controller.inputSource.targetRaySpace }).then((source) => {
                hitTestSource = source;
            });

            xr.baseExperience.sessionManager.onXRFrameObservable.add((xrFrame) => {
                if (!hitTestSource) return;
                const results = xrFrame.getHitTestResults(hitTestSource);
                const result = results[0] || null;
                currentResult = result;

                if (results.length) {
                    marker.isVisible = true;
                    const pose = result.getPose(referenceSpace);
                    const p = pose.transform.position;
                    const q = pose.transform.orientation;
                    marker.position.set(p.x, p.y, -p.z);
                    marker.rotationQuaternion.set(q.x, q.y, q.z, q.w);
                } else {
                    marker.isVisible = false;
                }
            });

            const rightTrigger = motionController.getComponent("xr-standard-trigger");
            if (rightTrigger) {
                rightTrigger.onButtonStateChangedObservable.add(() => {
                    if (!rightTrigger.pressed) return;
                    if (!currentResult || !marker.isVisible || !xr.baseExperience.sessionManager.inXRSession) return;

                    const pose = currentResult.getPose(referenceSpace);
                    if (!pose) return;

                    const newCrab = crab.clone("crab_" + Date.now());
                    newCrab.isVisible = true;

                    const p = pose.transform.position;
                    const q = pose.transform.orientation;

                    const bbox = newCrab.getBoundingInfo().boundingBox;
                    const heightOffset = (bbox.maximum.y - bbox.minimum.y) * newCrab.scaling.y;

                    newCrab.position.set(p.x, p.y + heightOffset * 0.5 + 0.01, -p.z);
                    newCrab.rotationQuaternion.set(q.x, q.y, q.z, q.w);

                    shadowGenerator.addShadowCaster(newCrab, true);
                    CrabList.push(newCrab);
                    selectedModel = newCrab;
                });
            }

            const rightSqueeze = motionController.getComponent("xr-standard-squeeze");
            if (rightSqueeze) {
                rightSqueeze.onButtonStateChangedObservable.add(() => {
                    if (!rightSqueeze.pressed) return;

                    const ray = controller.getForwardRay(10.0);
                    const pickInfo = scene.pickWithRay(ray, (mesh) => {
                        return CrabList.some(root => mesh === root || mesh.isDescendantOf && mesh.isDescendantOf(root));
                    });

                    if (pickInfo.hit && pickInfo.pickedMesh) {
                        if (selectedModel) hl.removeMesh(selectedModel);
                        selectedModel = CrabList.find(root => pickInfo.pickedMesh === root || (pickInfo.pickedMesh.isDescendantOf && pickInfo.pickedMesh.isDescendantOf(root))) || null;
                        if (selectedModel) hl.addMesh(selectedModel, BABYLON.Color3.White());
                    } else {
                        if (selectedModel) hl.removeMesh(selectedModel);
                        selectedModel = null;
                    }
                });
            }

            const rightThumbstick = motionController.getComponent("xr-standard-thumbstick");
            if (rightThumbstick) {
                rightThumbstick.onAxisValueChangedObservable.add((axes) => {
                    if (!selectedModel) return;

                    const movementSpeed = 0.05;
                    const camRotQ = xr.baseExperience.camera.rotationQuaternion || BABYLON.Quaternion.Identity();

                    const forward = new BABYLON.Vector3(0, 0, 1);
                    const right = new BABYLON.Vector3(1, 0, 0);

                    const rotatedForward = forward.rotateByQuaternionToRef(camRotQ, new BABYLON.Vector3());
                    const rotatedRight = right.rotateByQuaternionToRef(camRotQ, new BABYLON.Vector3());
                    rotatedForward.y = 0;
                    rotatedRight.y = 0;
                    rotatedForward.normalize();
                    rotatedRight.normalize();

                    const move = rotatedRight.scale(axes.x * movementSpeed).add(rotatedForward.scale(-axes.y * movementSpeed));
                    selectedModel.position.addInPlace(move);
                });
            }
        });
    });

    xr.baseExperience.sessionManager.onXRSessionEnded.add(() => {
        if (hitTestSource) {
            hitTestSource.cancel();
            hitTestSource = null;
        }
        if (selectedModel) {
            hl.removeMesh(selectedModel);
            selectedModel = null;
        }
    });

    return scene;
};
                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
        
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
